//
// Created by 王轲毅 on 16/7/24.
//

// CryptoTest.cpp: implementation of the CCryptoTest class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "CryptoTest.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
extern DEVHANDLE g_hDev;
extern HAPPLICATION g_hApp;
extern HCONTAINER g_hCurContainer;

CCryptoTest::CCryptoTest() : g_hSessionKey(NULL)
{

}

CCryptoTest::~CCryptoTest()
{

}

BOOL CCryptoTest::Test_GenRandom()
{
    SHOW_PROCESS("Test_GenRandom");
    if (NULL == g_hDev)
    {
        printf("Please connect first!\n");
        return FALSE;
    }

    BYTE byData[32] = {0};
    ULONG ulReval = SKF_GenRandom(g_hDev, byData, 8);
    SHOW_ERROR(ulReval);

    if (SAR_OK == ulReval)
    {
        GetUtilities().ShowBinHex(byData, 8);
    }

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_GenExtRSAKey()
{
    SHOW_PROCESS("Test_GenExtRSAKey");
    if (NULL == g_hDev)
    {
        printf("Please connect first!\n");
        return FALSE;
    }

    RSAPRIVATEKEYBLOB rsaBlob = {0};
    ULONG ulBitLen = 0;

    printf("Input Length(1024, 2048):  ");
    int ret = scanf("%d", &ulBitLen);
    if(ret != 1)
    {
        printf("error input\n");
        return FALSE;
    }
    if ((1024 != ulBitLen) && (2048 != ulBitLen))
    {
        return FALSE;
    }

    ULONG ulReval = SKF_GenExtRSAKey(g_hDev, ulBitLen, &rsaBlob);
    SHOW_ERROR_EX("GenExtRSAKey", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    RSAPUBLICKEYBLOB rsapubblob = {0};
    rsapubblob.AlgID = SGD_RSA;
    rsapubblob.BitLen = rsaBlob.BitLen;
    memcpy(rsapubblob.Modulus, rsaBlob.Modulus, MAX_RSA_MODULUS_LEN);
    memcpy(rsapubblob.PublicExponent, rsaBlob.PublicExponent, MAX_RSA_EXPONENT_LEN);

    CHAR msg[300] = "hello, how are you?";

    //ULONG ulMsgLen = rsaBlob.BitLen/8;
    ULONG ulMsgLen = strlen(msg);
    BYTE encryptmsg[300] = {0};
    ULONG ulEncryptLen = 300;

    ulReval = SKF_ExtRSAPubKeyOperation(g_hDev, &rsapubblob, (BYTE*)msg, ulMsgLen, encryptmsg, &ulEncryptLen);
    SHOW_ERROR_EX("ExtRSAPubKeyOperation", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    BYTE outmsg[300] = {0};
    ULONG ulOutMsgLen = 300;
    ulReval = SKF_ExtRSAPriKeyOperation(g_hDev, &rsaBlob, encryptmsg, ulEncryptLen, outmsg, &ulOutMsgLen);
    SHOW_ERROR_EX("ExtRSAPubKeyOperation", ulReval);

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_GenRSAKeyPair()
{
    SHOW_PROCESS("Test_GenRSAKeyPair");
    if (NULL == g_hCurContainer)
    {
        printf("Open container first!\n");
        return FALSE;
    }

    RSAPUBLICKEYBLOB rsaBlob;
    ULONG ulBitLen = 0;

    printf("Input Length(1024, 2048):");
    int ret = scanf("%d", &ulBitLen);
    if(ret != 1)
    {
        printf("error input\n");
        return FALSE;
    }
    if ((1024 != ulBitLen) && (2048 != ulBitLen))
    {
        return FALSE;
    }

    ULONG ulReval = SKF_GenRSAKeyPair(g_hCurContainer, ulBitLen, &rsaBlob);
    SHOW_ERROR(ulReval);
    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_RSAExportSessionKey()
{
    SHOW_PROCESS("Test_RSAExportSessionKey");
    if (NULL == g_hCurContainer)
    {
        printf("Open container first!\n");
        return FALSE;
    }

    RSAPUBLICKEYBLOB blob = {0};
    ULONG ulBlobLen = sizeof(RSAPUBLICKEYBLOB);
    ULONG ulReval = SKF_ExportPublicKey(g_hCurContainer, TRUE, (BYTE*)&blob, &ulBlobLen);
    SHOW_ERROR_EX("ExportPublicKey", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    BYTE encryptedsk[MAX_RSA_MODULUS_LEN] = {0};
    ULONG ulESKLen = MAX_RSA_MODULUS_LEN;
    HANDLE hSessionKey1 = 0, hSessionKey2 = 0;
    ulReval = SKF_RSAExportSessionKey(g_hCurContainer, SGD_SM1_ECB, &blob, encryptedsk, &ulESKLen, &hSessionKey1);
    SHOW_ERROR_EX("RSAExportSessionKey", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

//	ulReval = SKF_ImportSessionKey(g_hCurContainer, SGD_SM1_ECB, encryptedsk, ulESKLen, &hSessionKey2);
//	SHOW_ERROR_EX("ImportSessionKey", ulReval);

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_RSASignVerifyData()
{
    SHOW_PROCESS("Test_RSASignData");
    if (NULL == g_hCurContainer)
    {
        printf("Open container first!\n");
        return FALSE;
    }

    CHAR* testsign = "zhong hua ren min gong he guo!";
    ULONG ulMsgLen = strlen(testsign);
    BYTE signature[MAX_RSA_MODULUS_LEN] = {0};
    ULONG ulSigLen = MAX_RSA_MODULUS_LEN;

    ULONG ulReval = SKF_RSASignData(g_hCurContainer, (BYTE*)testsign, ulMsgLen, signature, &ulSigLen);
    SHOW_ERROR_EX("RSASignData", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    RSAPUBLICKEYBLOB blob = {0};
    ULONG ulBlobLen = sizeof(RSAPUBLICKEYBLOB);
    ulReval = SKF_ExportPublicKey(g_hCurContainer, TRUE, (BYTE*)&blob, &ulBlobLen);
    SHOW_ERROR_EX("ExportPublicKey",ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_RSAVerify(g_hDev, &blob, (BYTE*)testsign, ulMsgLen, signature, ulSigLen);
    SHOW_ERROR_EX("RSAVerify",ulReval);

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_ImportRSAKeyPair()
{
    SHOW_PROCESS("Test_ImportRSAKeyPair");
    if (NULL == g_hCurContainer)
    {
        printf("Open container first!\n");
        return FALSE;
    }
    BYTE prvblob1[] =
            {
                    0x30, 0x82, 0x02, 0x5D, 0x02, 0x01, 0x00, 0x02, 0x81, 0x81, 0x00, 0xEB, 0x1F, 0x4E, 0xB7, 0x41,
                    0x7D, 0xDB, 0x33, 0xFE, 0xAF, 0x56, 0x00, 0x34, 0xDD, 0x1B, 0xF1, 0xBC, 0xFB, 0x64, 0x6E, 0xE9,
                    0x39, 0x4C, 0x28, 0x6F, 0x1B, 0x1A, 0xC3, 0xDE, 0xCB, 0xDE, 0xF7, 0x3C, 0x98, 0xB2, 0x38, 0x9D,
                    0x13, 0xE8, 0xD7, 0x90, 0x37, 0x64, 0x66, 0x21, 0x83, 0x8C, 0xCE, 0x31, 0xBA, 0x81, 0x77, 0x08,
                    0xAB, 0x85, 0xD0, 0x6D, 0x45, 0xF2, 0x5F, 0x47, 0x7C, 0x58, 0x3B, 0x87, 0x2A, 0x25, 0x3E, 0x9D,
                    0xBF, 0xCF, 0x0F, 0x92, 0x8C, 0x5B, 0x4E, 0x20, 0xB8, 0x7A, 0x12, 0x94, 0xAF, 0x6E, 0x93, 0x0D,
                    0x70, 0xB2, 0xEB, 0xD5, 0xB9, 0xA6, 0xDC, 0x5D, 0xB8, 0xD2, 0x9E, 0x40, 0x3B, 0xC3, 0xC0, 0xB5,
                    0x38, 0x50, 0x8A, 0x3D, 0x95, 0x4B, 0x7B, 0xB9, 0xB6, 0x8D, 0xD7, 0x53, 0x2A, 0xC0, 0x8B, 0xDE,
                    0xF3, 0x19, 0x1D, 0x3E, 0x47, 0xE8, 0xEA, 0xD3, 0x90, 0x16, 0xE3, 0x02, 0x03, 0x01, 0x00, 0x01,
                    0x02, 0x81, 0x81, 0x00, 0xB9, 0x0E, 0x95, 0x28, 0x0B, 0x76, 0x01, 0x97, 0xB4, 0xF7, 0x4F, 0xDB,
                    0x2D, 0xC0, 0x72, 0x04, 0x1C, 0x58, 0x49, 0x3E, 0x3A, 0x76, 0x8C, 0x88, 0xAE, 0x9A, 0x48, 0xC0,
                    0xAD, 0x95, 0x0C, 0xD2, 0xCF, 0x70, 0xE7, 0xA5, 0x43, 0x8C, 0xAE, 0x11, 0x2C, 0x43, 0x4C, 0xD4,
                    0x4D, 0xC0, 0x7A, 0x8C, 0xB7, 0xFB, 0x31, 0x76, 0xFC, 0xED, 0xF3, 0x8E, 0x8E, 0xD3, 0x24, 0xE6,
                    0xF5, 0x1E, 0xDB, 0x59, 0xCC, 0xA2, 0x82, 0x95, 0x42, 0xC2, 0xDE, 0x71, 0xAE, 0x4A, 0xB1, 0x85,
                    0xA6, 0x08, 0x4B, 0xB3, 0x00, 0x44, 0x5F, 0x2E, 0x1A, 0x9B, 0x05, 0xC6, 0x44, 0x12, 0x10, 0xE9,
                    0xB9, 0xBB, 0x12, 0x06, 0x16, 0xB2, 0x74, 0xA4, 0x07, 0xF7, 0xD1, 0xCF, 0xA3, 0xA8, 0x11, 0xDC,
                    0x4C, 0xA7, 0x02, 0xB6, 0x0D, 0x2C, 0x0A, 0x2B, 0x3B, 0xE0, 0x44, 0x4B, 0x43, 0x7C, 0x23, 0xD2,
                    0x46, 0x7C, 0xE9, 0x41, 0x02, 0x41, 0x00, 0xFE, 0x11, 0xFC, 0xA2, 0x1C, 0xEF, 0x32, 0xA0, 0x6D,
                    0x36, 0x99, 0x3B, 0xB4, 0x17, 0x64, 0xEB, 0xC5, 0x84, 0x26, 0xC6, 0x0F, 0x93, 0xDF, 0x9E, 0x85,
                    0x80, 0x52, 0xA1, 0xA5, 0xC1, 0x35, 0x2A, 0xDE, 0xF2, 0x56, 0xA2, 0xFE, 0x1A, 0x6A, 0xC2, 0x8F,
                    0x33, 0xC3, 0xFB, 0x1A, 0x26, 0xFA, 0xCB, 0x99, 0x22, 0x44, 0x31, 0x9E, 0xC7, 0xBD, 0x20, 0x47,
                    0x76, 0x5B, 0xE5, 0x29, 0xE5, 0x69, 0x53, 0x02, 0x41, 0x00, 0xEC, 0xE8, 0x7A, 0x71, 0x23, 0xD6,
                    0x82, 0xD2, 0x8F, 0x78, 0xA3, 0x87, 0x34, 0x8C, 0x44, 0xED, 0xBC, 0x39, 0x3A, 0xAA, 0x96, 0xE2,
                    0xA1, 0x54, 0x12, 0xDE, 0xBA, 0xE4, 0xF9, 0xA2, 0x22, 0x50, 0x49, 0xCA, 0x16, 0xEF, 0xC6, 0x67,
                    0x4A, 0x85, 0x65, 0xFB, 0x8A, 0xEA, 0x45, 0xC1, 0x1B, 0xA6, 0xBB, 0x15, 0xB8, 0x65, 0xEE, 0xEB,
                    0x07, 0x48, 0x50, 0x25, 0x24, 0x03, 0x75, 0x29, 0x9A, 0x31, 0x02, 0x40, 0x6D, 0x81, 0xA5, 0x28,
                    0xDE, 0x5D, 0xBE, 0xAD, 0x64, 0xC5, 0x2E, 0xA0, 0x8C, 0x0B, 0xB5, 0x44, 0xE5, 0xBA, 0x02, 0xD8,
                    0x45, 0x28, 0x90, 0x2E, 0x8C, 0x0D, 0xF6, 0x0F, 0x94, 0x18, 0xC5, 0x68, 0xB7, 0xF5, 0x2D, 0xA0,
                    0x4C, 0xF3, 0x67, 0xE6, 0x79, 0xC0, 0x6F, 0x0D, 0x10, 0x85, 0x92, 0x7D, 0x24, 0x80, 0x9F, 0x71,
                    0xDF, 0xA4, 0xE9, 0x80, 0x3B, 0x2C, 0xE9, 0x88, 0xC9, 0x59, 0x06, 0xDF, 0x02, 0x40, 0x33, 0xCE,
                    0xF3, 0x57, 0xE2, 0xBA, 0x7A, 0x89, 0x89, 0x8E, 0x9C, 0x54, 0x69, 0x0D, 0x73, 0xD5, 0x79, 0xA0,
                    0x1A, 0x50, 0x4C, 0x06, 0xEB, 0xB8, 0xF3, 0x17, 0x7A, 0x4F, 0xB0, 0xB7, 0xE0, 0x41, 0x26, 0xA1,
                    0xE7, 0x3A, 0x30, 0x6D, 0x4E, 0x42, 0xB5, 0xF6, 0xB8, 0x7E, 0x5B, 0x1A, 0xCB, 0xED, 0x3E, 0x64,
                    0x95, 0x9A, 0xD5, 0x10, 0xD8, 0xDA, 0xDB, 0x8C, 0x03, 0xC0, 0x2D, 0xD3, 0x17, 0x41, 0x02, 0x41,
                    0x00, 0xE8, 0x99, 0x64, 0x60, 0x91, 0x56, 0x4E, 0x5E, 0x63, 0x52, 0x17, 0x3E, 0x9A, 0x96, 0xE2,
                    0x50, 0xB7, 0xA1, 0x7E, 0x73, 0xAF, 0x45, 0x88, 0x8B, 0x26, 0xC6, 0x16, 0x32, 0xA3, 0x6A, 0xA2,
                    0x77, 0x4A, 0xD3, 0xB0, 0xF1, 0xAF, 0x0A, 0x85, 0xC9, 0x0E, 0x5E, 0x7A, 0xF6, 0x05, 0x6D, 0x0F,
                    0xBA, 0xD7, 0x96, 0x87, 0xAC, 0x56, 0xD0, 0x8D, 0x8A, 0xD4, 0x60, 0xF8, 0xE2, 0x23, 0xF7, 0x2E,
                    0x9E
            };

    RSAPUBLICKEYBLOB pubblob1 =
            {
                    SGD_RSA,
                    0x0400,
                    {
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

                            0xEB, 0x1F, 0x4E, 0xB7, 0x41, 0x7D, 0xDB, 0x33, 0xFE, 0xAF, 0x56, 0x00, 0x34, 0xDD, 0x1B, 0xF1,
                            0xBC, 0xFB, 0x64, 0x6E, 0xE9, 0x39, 0x4C, 0x28, 0x6F, 0x1B, 0x1A, 0xC3, 0xDE, 0xCB, 0xDE, 0xF7,
                            0x3C, 0x98, 0xB2, 0x38, 0x9D, 0x13, 0xE8, 0xD7, 0x90, 0x37, 0x64, 0x66, 0x21, 0x83, 0x8C, 0xCE,
                            0x31, 0xBA, 0x81, 0x77, 0x08, 0xAB, 0x85, 0xD0, 0x6D, 0x45, 0xF2, 0x5F, 0x47, 0x7C, 0x58, 0x3B,
                            0x87, 0x2A, 0x25, 0x3E, 0x9D, 0xBF, 0xCF, 0x0F, 0x92, 0x8C, 0x5B, 0x4E, 0x20, 0xB8, 0x7A, 0x12,
                            0x94, 0xAF, 0x6E, 0x93, 0x0D, 0x70, 0xB2, 0xEB, 0xD5, 0xB9, 0xA6, 0xDC, 0x5D, 0xB8, 0xD2, 0x9E,
                            0x40, 0x3B, 0xC3, 0xC0, 0xB5, 0x38, 0x50, 0x8A, 0x3D, 0x95, 0x4B, 0x7B, 0xB9, 0xB6, 0x8D, 0xD7,
                            0x53, 0x2A, 0xC0, 0x8B, 0xDE, 0xF3, 0x19, 0x1D, 0x3E, 0x47, 0xE8, 0xEA, 0xD3, 0x90, 0x16, 0xE3

                    },
                    {
                            0x00, 0x01, 0x00, 0x01
                    }
            };

    BYTE prvblob3[] =
            {
                    0x30, 0x82, 0x04, 0xA4, 0x02, 0x01, 0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB5, 0x5E, 0x9C, 0x15,
                    0x65, 0x29, 0xDD, 0xF8, 0xA3, 0x91, 0x7B, 0x83, 0xD6, 0xEC, 0x47, 0x1C, 0x78, 0xAA, 0xD1, 0x2A,
                    0xBD, 0xFC, 0xD8, 0x6E, 0x99, 0x3F, 0x7C, 0x73, 0x34, 0x51, 0xA8, 0x6D, 0x44, 0x3B, 0x3A, 0x00,
                    0xD8, 0x2E, 0x07, 0xBB, 0x9D, 0xFD, 0x0F, 0x99, 0x79, 0xBB, 0x33, 0x10, 0xBC, 0x89, 0xE2, 0x24,
                    0x4C, 0x18, 0xD3, 0xF8, 0x53, 0x85, 0x2C, 0xD1, 0x1F, 0xA6, 0x08, 0x5B, 0x62, 0x14, 0xD3, 0x28,
                    0x93, 0xC9, 0xC7, 0xEC, 0xDA, 0xF1, 0xF5, 0x7E, 0x91, 0x99, 0xA4, 0xB5, 0xD8, 0xB6, 0xEA, 0x35,
                    0x71, 0x36, 0x45, 0x5E, 0xBB, 0x2B, 0x6E, 0x54, 0x6B, 0xC7, 0x11, 0xC7, 0x49, 0xF5, 0x4F, 0xD6,
                    0x16, 0xB8, 0x5A, 0x12, 0x25, 0x96, 0x80, 0xEE, 0x75, 0x37, 0x85, 0xCC, 0x89, 0xF6, 0xD3, 0x1B,
                    0x90, 0x09, 0xD3, 0x36, 0x32, 0xDF, 0x53, 0x23, 0x72, 0x12, 0xCD, 0xA3, 0xBB, 0x11, 0x79, 0x09,
                    0x92, 0xBB, 0x1E, 0xE9, 0x74, 0xCD, 0xBF, 0x24, 0x3D, 0x2A, 0x95, 0x13, 0x48, 0x16, 0x34, 0xDF,
                    0xDD, 0x44, 0x70, 0xFA, 0x07, 0x6F, 0x6D, 0x94, 0x02, 0x44, 0xC7, 0xF2, 0xB4, 0x68, 0x84, 0x96,
                    0x69, 0x7B, 0xBF, 0x27, 0xD2, 0xF9, 0xB7, 0xCB, 0x05, 0x68, 0xAF, 0x33, 0xBA, 0x8A, 0xA8, 0x7B,
                    0x44, 0x45, 0xF4, 0xF0, 0xC9, 0x45, 0xAE, 0x19, 0x47, 0xD4, 0xC2, 0xFC, 0x41, 0x99, 0x9D, 0xC8,
                    0x22, 0xBB, 0x10, 0x93, 0x8C, 0x92, 0x97, 0xDC, 0xED, 0x3F, 0x54, 0x3F, 0xE0, 0xBC, 0xF7, 0xDA,
                    0x44, 0x71, 0x86, 0xF8, 0x06, 0x7D, 0x52, 0x0D, 0xCB, 0x3E, 0x22, 0xF5, 0x1A, 0xF2, 0x9A, 0xE6,
                    0xB3, 0x75, 0x5D, 0x61, 0x6B, 0x38, 0xF7, 0xEB, 0x40, 0x5C, 0x1A, 0xE4, 0xCF, 0x55, 0xAA, 0x47,
                    0xFF, 0xD7, 0x9F, 0xAC, 0xBB, 0xC7, 0x95, 0x78, 0xFA, 0x71, 0xD6, 0xFB, 0x02, 0x03, 0x01, 0x00,
                    0x01, 0x02, 0x82, 0x01, 0x01, 0x00, 0x8B, 0x6E, 0x8B, 0x92, 0x0B, 0x2E, 0xCF, 0x9E, 0x09, 0xA9,
                    0x9B, 0x8A, 0x34, 0x9D, 0x7A, 0xE1, 0xD1, 0x86, 0x88, 0xBD, 0x52, 0x47, 0xE2, 0xDF, 0xCB, 0xE2,
                    0xB9, 0xBB, 0x1B, 0x7A, 0xB7, 0x80, 0x21, 0x17, 0x63, 0x35, 0x28, 0xFC, 0xE2, 0x27, 0x03, 0x83,
                    0x7C, 0x0D, 0xA2, 0x3F, 0x1F, 0x37, 0xFB, 0xAA, 0x08, 0xF7, 0x9C, 0xA4, 0xED, 0xB8, 0x98, 0x04,
                    0xE6, 0xFA, 0x72, 0x59, 0x43, 0x4D, 0x75, 0xAE, 0xCA, 0xD3, 0x04, 0x22, 0xF9, 0x17, 0x07, 0x0F,
                    0x42, 0x8B, 0x26, 0x46, 0x37, 0x11, 0x31, 0xE5, 0x15, 0x53, 0x36, 0x90, 0xE1, 0x6D, 0xBD, 0x78,
                    0xDB, 0x1D, 0xFD, 0xA9, 0x91, 0xEA, 0x62, 0xDA, 0x3B, 0xA1, 0x3B, 0xE0, 0x48, 0x26, 0x71, 0x4D,
                    0x2E, 0x1B, 0xA4, 0x73, 0xA5, 0xE2, 0x24, 0x22, 0x64, 0x13, 0x69, 0x7D, 0x94, 0x29, 0xB3, 0x9C,
                    0x6A, 0x9E, 0xF2, 0x60, 0xB0, 0x43, 0xA4, 0xFE, 0xE8, 0x20, 0xF4, 0x9A, 0x2D, 0x78, 0x72, 0x02,
                    0xB5, 0xEE, 0xDE, 0x94, 0x51, 0x6F, 0xCA, 0xB2, 0xFE, 0x62, 0x7A, 0x43, 0x53, 0x77, 0x7C, 0x74,
                    0x8C, 0x1E, 0x70, 0xE0, 0xB9, 0xA8, 0xE0, 0x15, 0xAB, 0x1B, 0x78, 0x29, 0x0A, 0x37, 0x61, 0x99,
                    0xB5, 0xA9, 0xF3, 0x6B, 0xDF, 0xC8, 0x92, 0x36, 0xD4, 0x11, 0xB4, 0x76, 0x68, 0x55, 0xB9, 0x0C,
                    0x98, 0xAD, 0x8B, 0xFD, 0xBB, 0x80, 0xAB, 0xB6, 0xDC, 0x37, 0xB8, 0xDB, 0x13, 0xE0, 0xCA, 0x36,
                    0x65, 0xD7, 0x5A, 0xA6, 0x4F, 0x20, 0x09, 0x4F, 0xF4, 0x95, 0x6F, 0x6B, 0x60, 0x79, 0xAE, 0xB0,
                    0x4A, 0x44, 0xBB, 0x56, 0x3E, 0xF9, 0xAE, 0xF2, 0x43, 0xA2, 0xEB, 0xC1, 0xB3, 0x30, 0x63, 0xFB,
                    0x6E, 0x99, 0x7B, 0x5D, 0x43, 0x63, 0xFA, 0xF0, 0x4A, 0xDC, 0xDA, 0xE2, 0x56, 0xE6, 0x18, 0xE4,
                    0x7E, 0x9F, 0x37, 0xD7, 0x5F, 0x69, 0x02, 0x81, 0x81, 0x00, 0xF0, 0xC8, 0x4C, 0xE3, 0xD0, 0x34,
                    0xA2, 0x0C, 0x02, 0xC9, 0xE6, 0x41, 0x73, 0xE3, 0xE9, 0xC8, 0xB5, 0xAE, 0x23, 0x8B, 0x10, 0x0B,
                    0xA6, 0x00, 0xF0, 0xC3, 0x55, 0x08, 0x37, 0xE6, 0x50, 0x69, 0x18, 0x17, 0x46, 0xC1, 0x76, 0x67,
                    0xAD, 0x18, 0x9B, 0x5F, 0x22, 0x85, 0xFF, 0x18, 0x61, 0xD0, 0x52, 0x1D, 0x5A, 0x9B, 0x85, 0x3B,
                    0xDD, 0xC0, 0x78, 0x6F, 0x5E, 0x53, 0x01, 0xD7, 0x95, 0x6B, 0xEB, 0x0B, 0x41, 0x96, 0x0F, 0x0A,
                    0xED, 0x07, 0x35, 0x10, 0x34, 0x22, 0x4C, 0x69, 0x9F, 0x58, 0x9A, 0x9C, 0x74, 0x52, 0x0F, 0x64,
                    0x62, 0x42, 0x87, 0x0C, 0xD7, 0x1D, 0xC0, 0x70, 0x26, 0x79, 0x52, 0x82, 0x46, 0x07, 0x26, 0xA2,
                    0x06, 0x89, 0x22, 0x45, 0x0B, 0x68, 0x77, 0xE1, 0x7C, 0x46, 0xCC, 0x4A, 0x98, 0x46, 0x8E, 0xB4,
                    0xED, 0xF4, 0x14, 0x42, 0xBD, 0xC9, 0xFD, 0x08, 0x1C, 0xCF, 0x02, 0x81, 0x81, 0x00, 0xC0, 0xD5,
                    0x0C, 0x80, 0xD4, 0x54, 0x2A, 0x14, 0xB7, 0x03, 0xE9, 0xDE, 0x75, 0xAA, 0x7B, 0x53, 0x4A, 0x53,
                    0xD1, 0xB5, 0x6B, 0x8F, 0x36, 0x96, 0x0C, 0x6F, 0x07, 0x4F, 0xA4, 0x05, 0x71, 0x96, 0xF1, 0xD5,
                    0x8F, 0xE0, 0x14, 0xAF, 0xE9, 0x10, 0x2B, 0x15, 0x66, 0xCE, 0x0C, 0xFF, 0x06, 0x39, 0xBC, 0xED,
                    0xA9, 0x35, 0x72, 0x33, 0xE8, 0xAD, 0x06, 0x19, 0x12, 0xC3, 0xE8, 0x44, 0x5D, 0xD1, 0x18, 0x69,
                    0x6B, 0xC9, 0x57, 0x1A, 0xD5, 0x2C, 0x59, 0x81, 0x57, 0xB4, 0x0F, 0x9E, 0x88, 0x48, 0xE2, 0x62,
                    0xAE, 0x1D, 0x56, 0x3D, 0xED, 0x67, 0xFD, 0x7D, 0xAD, 0x0E, 0xAC, 0x46, 0xBF, 0x26, 0x72, 0x57,
                    0x15, 0xF5, 0x58, 0x8E, 0xF4, 0x09, 0xA9, 0x7A, 0x9E, 0xCD, 0x21, 0x30, 0xDA, 0x8E, 0xB7, 0x56,
                    0xBF, 0xBA, 0x1A, 0xD8, 0xFF, 0xD5, 0xE9, 0x8B, 0x66, 0x4A, 0x63, 0x23, 0x66, 0x15, 0x02, 0x81,
                    0x80, 0x0A, 0x51, 0x0A, 0xBA, 0x58, 0x19, 0x69, 0x38, 0x0A, 0x86, 0x8C, 0x0F, 0x11, 0xE0, 0x1A,
                    0x0C, 0x37, 0x7C, 0x96, 0x99, 0x46, 0xBE, 0xB9, 0x06, 0x21, 0x4A, 0xBD, 0x41, 0xF4, 0xE3, 0x31,
                    0x5E, 0xCF, 0x61, 0x6F, 0xEE, 0xAA, 0x1C, 0x17, 0x16, 0x8E, 0xD1, 0xAC, 0xB1, 0x01, 0x15, 0x12,
                    0x5B, 0xD2, 0xA8, 0xDF, 0x50, 0xFA, 0x8C, 0x6E, 0x1B, 0xE9, 0x0D, 0x1C, 0x85, 0x81, 0xF6, 0xB2,
                    0xB8, 0x45, 0x01, 0xDE, 0x75, 0x87, 0x7F, 0x78, 0x58, 0x6E, 0xB5, 0x9B, 0x06, 0x3D, 0x2F, 0xE9,
                    0x5B, 0xEA, 0x83, 0xF9, 0x97, 0xEA, 0x80, 0xEA, 0x94, 0xDF, 0x24, 0x75, 0xB3, 0x18, 0xA3, 0xB5,
                    0x82, 0x4D, 0x3E, 0xB7, 0xB1, 0x66, 0xBE, 0x5A, 0x79, 0x55, 0xB6, 0x8F, 0x9E, 0x92, 0x44, 0x5F,
                    0x06, 0xC9, 0x8A, 0x08, 0xAC, 0x3D, 0x41, 0x13, 0x50, 0xF9, 0xED, 0x42, 0x24, 0x7D, 0x6A, 0xF3,
                    0x91, 0x02, 0x81, 0x80, 0x5D, 0xD2, 0x8B, 0x3D, 0xD7, 0x91, 0x87, 0xD4, 0x02, 0x64, 0x1E, 0x13,
                    0x46, 0x2F, 0x07, 0xC8, 0x33, 0xBE, 0xEA, 0xA7, 0x19, 0xC9, 0x59, 0xA6, 0xD2, 0x2F, 0xE7, 0x5F,
                    0xC1, 0x8F, 0x80, 0x80, 0x0F, 0xF4, 0x78, 0x07, 0x70, 0x29, 0x52, 0xFD, 0xB1, 0xE8, 0xBC, 0xD7,
                    0x7E, 0x8D, 0x4A, 0xEB, 0x26, 0xD8, 0x7F, 0xDE, 0xE8, 0x4D, 0x07, 0x65, 0xC0, 0x34, 0xCC, 0xE3,
                    0x93, 0x0C, 0x48, 0x95, 0x67, 0x0A, 0x4C, 0x0E, 0x6F, 0x9A, 0x37, 0xA4, 0x57, 0x7C, 0x4E, 0x3E,
                    0xE6, 0xE6, 0x9C, 0xAA, 0xD1, 0xB3, 0x6F, 0xC2, 0x08, 0x67, 0x23, 0x2E, 0xD8, 0xB0, 0xA0, 0x56,
                    0x26, 0x4E, 0x59, 0xCD, 0x0C, 0x0F, 0x01, 0x39, 0x19, 0xB8, 0x9C, 0x56, 0x63, 0x26, 0xAD, 0x43,
                    0x63, 0x65, 0xD0, 0xC1, 0x65, 0xC5, 0x08, 0x8E, 0x35, 0x67, 0xE5, 0xBA, 0x9F, 0xE2, 0x5A, 0x87,
                    0xD1, 0x0A, 0xB5, 0x2D, 0x02, 0x81, 0x81, 0x00, 0xE9, 0x32, 0x86, 0xBD, 0xDA, 0x25, 0x26, 0x10,
                    0x66, 0xB2, 0x6D, 0x19, 0xC8, 0x28, 0x1D, 0xF3, 0xB0, 0x0F, 0x3C, 0x78, 0xB7, 0x7F, 0x8E, 0x4A,
                    0x9A, 0x7F, 0x35, 0x61, 0x7F, 0xCD, 0xEC, 0x2A, 0x05, 0x2F, 0xFC, 0xC1, 0xDC, 0x97, 0x09, 0x53,
                    0x40, 0xF9, 0x29, 0xDD, 0x75, 0x98, 0x22, 0xED, 0x6F, 0x99, 0xF9, 0xFE, 0x10, 0xCC, 0xC3, 0x53,
                    0x27, 0xB0, 0x6C, 0x2B, 0x04, 0xDB, 0x91, 0x0E, 0x2C, 0xF5, 0x6B, 0x2D, 0x88, 0x49, 0x51, 0xCD,
                    0x3B, 0x6B, 0xB1, 0x97, 0xFE, 0x3B, 0x36, 0x09, 0xC5, 0xEC, 0xF0, 0xFA, 0x67, 0x1E, 0xF5, 0x11,
                    0xEE, 0x92, 0xFC, 0xEA, 0x0A, 0x1A, 0x05, 0x60, 0x7A, 0x7A, 0x6B, 0xA8, 0x3E, 0xAC, 0x94, 0x95,
                    0xDB, 0x17, 0xA4, 0xAE, 0x57, 0x32, 0x33, 0xA4, 0x99, 0x20, 0x00, 0xDA, 0x2E, 0x8A, 0x7A, 0x2B,
                    0x33, 0x70, 0x8C, 0x93, 0x63, 0xAE, 0x3A, 0xA7
            };

    RSAPUBLICKEYBLOB pubblob3 =
            {
                    SGD_RSA,
                    0x0800,
                    {
                            0xb5, 0x5e, 0x9c, 0x15, 0x65, 0x29, 0xdd, 0xf8, 0xa3, 0x91, 0x7b, 0x83, 0xd6, 0xec, 0x47, 0x1c,
                            0x78, 0xaa, 0xd1, 0x2a, 0xbd, 0xfc, 0xd8, 0x6e, 0x99, 0x3f, 0x7c, 0x73, 0x34, 0x51, 0xa8, 0x6d,
                            0x44, 0x3b, 0x3a, 0x00, 0xd8, 0x2e, 0x07, 0xbb, 0x9d, 0xfd, 0x0f, 0x99, 0x79, 0xbb, 0x33, 0x10,
                            0xbc, 0x89, 0xe2, 0x24, 0x4c, 0x18, 0xd3, 0xf8, 0x53, 0x85, 0x2c, 0xd1, 0x1f, 0xa6, 0x08, 0x5b,
                            0x62, 0x14, 0xd3, 0x28, 0x93, 0xc9, 0xc7, 0xec, 0xda, 0xf1, 0xf5, 0x7e, 0x91, 0x99, 0xa4, 0xb5,
                            0xd8, 0xb6, 0xea, 0x35, 0x71, 0x36, 0x45, 0x5e, 0xbb, 0x2b, 0x6e, 0x54, 0x6b, 0xc7, 0x11, 0xc7,
                            0x49, 0xf5, 0x4f, 0xd6, 0x16, 0xb8, 0x5a, 0x12, 0x25, 0x96, 0x80, 0xee, 0x75, 0x37, 0x85, 0xcc,
                            0x89, 0xf6, 0xd3, 0x1b, 0x90, 0x09, 0xd3, 0x36, 0x32, 0xdf, 0x53, 0x23, 0x72, 0x12, 0xcd, 0xa3,
                            0xbb, 0x11, 0x79, 0x09, 0x92, 0xbb, 0x1e, 0xe9, 0x74, 0xcd, 0xbf, 0x24, 0x3d, 0x2a, 0x95, 0x13,
                            0x48, 0x16, 0x34, 0xdf, 0xdd, 0x44, 0x70, 0xfa, 0x07, 0x6f, 0x6d, 0x94, 0x02, 0x44, 0xc7, 0xf2,
                            0xb4, 0x68, 0x84, 0x96, 0x69, 0x7b, 0xbf, 0x27, 0xd2, 0xf9, 0xb7, 0xcb, 0x05, 0x68, 0xaf, 0x33,
                            0xba, 0x8a, 0xa8, 0x7b, 0x44, 0x45, 0xf4, 0xf0, 0xc9, 0x45, 0xae, 0x19, 0x47, 0xd4, 0xc2, 0xfc,
                            0x41, 0x99, 0x9d, 0xc8, 0x22, 0xbb, 0x10, 0x93, 0x8c, 0x92, 0x97, 0xdc, 0xed, 0x3f, 0x54, 0x3f,
                            0xe0, 0xbc, 0xf7, 0xda, 0x44, 0x71, 0x86, 0xf8, 0x06, 0x7d, 0x52, 0x0d, 0xcb, 0x3e, 0x22, 0xf5,
                            0x1a, 0xf2, 0x9a, 0xe6, 0xb3, 0x75, 0x5d, 0x61, 0x6b, 0x38, 0xf7, 0xeb, 0x40, 0x5c, 0x1a, 0xe4,
                            0xcf, 0x55, 0xaa, 0x47, 0xff, 0xd7, 0x9f, 0xac, 0xbb, 0xc7, 0x95, 0x78, 0xfa, 0x71, 0xd6, 0xfb
                    },
                    {
                            0x00, 0x01, 0x00, 0x01
                    }
            };

    BYTE* DerPrvKey[] = {prvblob1, prvblob3};
    ULONG ulDerPrvKeyLen[] = {sizeof(prvblob1), sizeof(prvblob3)};
    RSAPUBLICKEYBLOB* pubkey[] = {&pubblob1, &pubblob3};

    for (BYTE i = 0; i < sizeof(DerPrvKey)/sizeof(BYTE*); ++i)
    {
        BYTE encryptedsk[MAX_RSA_MODULUS_LEN] = {0};
        ULONG ulESKLen = MAX_RSA_MODULUS_LEN;
        BYTE decryptedsk[MAX_RSA_MODULUS_LEN] = {0};
        ULONG ulDSKLen = MAX_RSA_MODULUS_LEN;
        HANDLE hSessionKey1 = 0;

        RSAPUBLICKEYBLOB blob = {0};
        ULONG ulBlobLen = sizeof(RSAPUBLICKEYBLOB);

        ULONG ulReval = SKF_GenRSAKeyPair(g_hCurContainer, 2048, &blob);

// 		ULONG ulReval = SKF_ExportPublicKey(g_hCurContainer, TRUE, (BYTE*)&blob, &ulBlobLen);
// 		ShowErrInfo(ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

        ulReval = SKF_RSAExportSessionKey(g_hCurContainer, SGD_SM1_ECB, &blob, encryptedsk, &ulESKLen, &hSessionKey1);
        SHOW_ERROR_EX("RSAExportSessionKey", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;


        BLOCKCIPHERPARAM param = {0};
        memset(param.IV, 0x00, 16);
        param.IVLen = 16;
        param.PaddingType = 1;

        ulReval = SKF_EncryptInit(hSessionKey1, param);
        SHOW_ERROR_EX("EncryptInit", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

        ULONG ulCipherLen1 = 0;
        ulReval = SKF_Encrypt(hSessionKey1, DerPrvKey[i], ulDerPrvKeyLen[i], NULL, &ulCipherLen1);
        SHOW_ERROR_EX("Encrypt1", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

        BYTE encryptRSA[2048] = {0};
        ulReval = SKF_Encrypt(hSessionKey1, DerPrvKey[i], ulDerPrvKeyLen[i], encryptRSA, &ulCipherLen1);
        SHOW_ERROR_EX("Encrypt2", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

/*		ulReval = SKF_DecryptInit(hSessionKey1, param);
		SHOW_ERROR_EX("DecryptInit", ulReval);
		if (SAR_OK != ulReval)
			return FALSE;

		BYTE ext[2048] = {0};
		ULONG ulExtLen = 2048;

		ulReval = SKF_Decrypt(hSessionKey1, (BYTE*)encryptRSA, ulCipherLen1, NULL, &ulExtLen);
		SHOW_ERROR_EX("Decrypt1", ulReval);
		if (SAR_OK != ulReval)
			return FALSE;

		ulReval = SKF_Decrypt(hSessionKey1, (BYTE*)encryptRSA, ulCipherLen1, ext, &ulExtLen);
		SHOW_ERROR_EX("Decrypt2", ulReval);
		if (SAR_OK != ulReval)
			return FALSE;

		if ((ulExtLen != ulDerPrvKeyLen[i]) || 0 != memcmp(ext, DerPrvKey[i], ulESKLen))
		{
			SHOW_ERROR(SAR_FAIL);
			return FALSE;
		}
*/
        ulReval = SKF_ImportRSAKeyPair(g_hCurContainer, SGD_SM1_ECB, encryptedsk, ulESKLen, encryptRSA, ulCipherLen1);
        SHOW_ERROR_EX("ImportRSAKeyPair", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

        ulReval = SKF_ExportPublicKey(g_hCurContainer, FALSE, (BYTE*)&blob, &ulBlobLen);
        SHOW_ERROR_EX("ExportPublicKey", ulReval);
        if (SAR_OK != ulReval)
            return FALSE;

        if (0 != memcmp((BYTE*)&blob, pubkey[i], sizeof(RSAPUBLICKEYBLOB)))
        {
            SHOW_ERROR(SAR_FAIL);
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CCryptoTest::Test_SetSymmKey()
{
    SHOW_PROCESS("Test_SetSymmKey");

    BYTE devKey[16] = {0};
    memset(devKey, 0x31, 16);

    ULONG ulReval = SKF_SetSymmKey(g_hDev, devKey, SGD_SM1_ECB, &g_hSessionKey);
    SHOW_ERROR(ulReval);

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_EncryptDecrypt()
{
    SHOW_PROCESS("Test_EncryptDecrypt");

    BYTE devKey[16] = {0};
    memset(devKey, 0x31, 16);

    BYTE plaintext[256] = {0}, ciphertext1[300] = {0}, ciphertext2[300] = {0};
    ULONG ulPlainLen1 = 256, ulPlainLen2 = 256, ulCipherLen2 = 300, ulCipherLen1 = 300;
    ULONG ulTempCipherLen = 256;

    ULONG ulReval = SKF_SetSymmKey(g_hDev, devKey, SGD_SM1_CBC, &g_hSessionKey);
    SHOW_ERROR_EX("SetSymmKey", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    BLOCKCIPHERPARAM param = {0};
    memset(param.IV, 0x01, 16);
    param.IVLen = 16;

    ulReval = SKF_EncryptInit(g_hSessionKey, param);
    SHOW_ERROR_EX("EncryptInit1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_Encrypt(g_hSessionKey, plaintext, ulPlainLen1, NULL, &ulCipherLen1);
    SHOW_ERROR_EX("Encrypt1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;


    ulReval = SKF_Encrypt(g_hSessionKey, plaintext, ulPlainLen1, ciphertext1, &ulCipherLen1);
    SHOW_ERROR_EX("Encrypt2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;


    ulReval = SKF_EncryptInit(g_hSessionKey, param);
    SHOW_ERROR_EX("EncryptInit2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_EncryptUpdate(g_hSessionKey, plaintext, 37, NULL, &ulTempCipherLen);
    SHOW_ERROR_EX("EncryptUpdate1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_EncryptUpdate(g_hSessionKey, plaintext, 37, ciphertext2, &ulTempCipherLen);
    SHOW_ERROR_EX("EncryptUpdate2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulCipherLen2 = 300;
    ulReval = SKF_EncryptUpdate(g_hSessionKey, plaintext + 37, ulPlainLen1 - 37, ciphertext2 + ulTempCipherLen, &ulCipherLen2);
    SHOW_ERROR_EX("EncryptUpdate3", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulTempCipherLen += ulCipherLen2;

    ulCipherLen2 = 300;
    ulReval = SKF_EncryptFinal(g_hSessionKey, ciphertext2 + ulTempCipherLen, &ulCipherLen2);
    SHOW_ERROR_EX("EncryptFinal1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulCipherLen2 += ulTempCipherLen;

    // compare
    if (ulCipherLen1 != ulCipherLen2)
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }
    if (memcmp(ciphertext1, ciphertext2, ulCipherLen1))
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }

    ulReval = SKF_DecryptInit(g_hSessionKey, param);
    SHOW_ERROR_EX("DecryptInit1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;
    BYTE decryptresult[300] = {0};
    ULONG ulDecryptLen1 = 300, ulDecryptLen2 = 300, ulDecryptLen3 = 300;
    ulReval = SKF_Decrypt(g_hSessionKey, ciphertext2, 64, NULL, &ulDecryptLen1);
    SHOW_ERROR_EX("Decrypt1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_Decrypt(g_hSessionKey, ciphertext2, 64, decryptresult, &ulDecryptLen1);
    SHOW_ERROR_EX("Decrypt2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_DecryptInit(g_hSessionKey, param);
    SHOW_ERROR_EX("DecryptInit1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    //BYTE decryptresult[300] = {0};
    //ULONG ulDecryptLen1 = 300, ulDecryptLen2 = 300, ulDecryptLen3 = 300;
    ulReval = SKF_DecryptUpdate(g_hSessionKey, ciphertext2, 40, decryptresult, &ulDecryptLen1);
    SHOW_ERROR_EX("DecryptUpdate1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_DecryptUpdate(g_hSessionKey, ciphertext2 + 40, ulCipherLen2 - 40, decryptresult + ulDecryptLen1, &ulDecryptLen2);
    SHOW_ERROR_EX("DecryptUpdate2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulDecryptLen2 += ulDecryptLen1;

    ulReval = SKF_DecryptFinal(g_hSessionKey, decryptresult + ulDecryptLen2, &ulDecryptLen3);
    SHOW_ERROR_EX("DecryptFinal1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulDecryptLen2+=ulDecryptLen3;
    if (ulPlainLen1 != ulDecryptLen2)
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }
    if (memcmp(decryptresult, plaintext, ulPlainLen1))
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }
    return (SAR_OK == ulReval);
}


BOOL CCryptoTest::Test_Digest()
{
    SHOW_PROCESS("Test_Digest");

    BYTE plainText[300] = {0};
    BYTE ciphertext1[300] = {0}, ciphertext2[300] = {0};
    ULONG ulCipherLen1 = 300, ulCipherLen2 = 300, ulPlainText = 300;
    HANDLE hDigest = NULL;
    ULONG ulReval = SKF_DigestInit(g_hDev, SGD_SHA256, NULL, NULL, 0, &hDigest);
    SHOW_ERROR_EX("DigestInit1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_Digest(hDigest, plainText, ulPlainText, ciphertext1, &ulCipherLen1);
    SHOW_ERROR_EX("Digest1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;


    ulReval = SKF_DigestInit(g_hDev, SGD_SHA256, NULL, NULL, 0, &hDigest);
    SHOW_ERROR_EX("DigestInit2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_DigestUpdate(hDigest, plainText, 100);
    SHOW_ERROR_EX("DigestUpdate1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;
    ulReval = SKF_DigestUpdate(hDigest, plainText + 100, ulPlainText - 100);
    SHOW_ERROR_EX("DigestUpdate2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_DigestFinal(hDigest, ciphertext2, &ulCipherLen2);
    SHOW_ERROR_EX("DigestFinal", ulReval);

    if (ulCipherLen2 != ulCipherLen1 || 0 != memcmp(ciphertext1, ciphertext2, ulCipherLen1))
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }

    return (SAR_OK == ulReval);
}



BOOL CCryptoTest::Test_Mac()
{
    SHOW_PROCESS("Test_Mac");
    BYTE devKey[16] = {0};
    memset(devKey, 0x31, 16);

    BYTE plaintext[256] = {0}, ciphertext1[300] = {0}, ciphertext2[300] = {0};
    ULONG ulPlainLen1 = 256, ulPlainLen2 = 256, ulCipherLen2 = 300, ulCipherLen1 = 300;
    ULONG ulTempCipherLen = 256;

    ULONG ulReval = SKF_SetSymmKey(g_hDev, devKey, SGD_SM1_CBC, &g_hSessionKey);
    SHOW_ERROR_EX("SetSymmKey", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    BLOCKCIPHERPARAM param = {0};
    memset(param.IV, 0x01, 16);
    param.IVLen = 16;
    param.PaddingType = 1;
    param.FeedBitLen = 0;

/*	ulReval = SKF_EncryptInit(g_hSessionKey, param);
	SHOW_ERROR_EX("EncryptInit", ulReval);
	if (SAR_OK != ulReval)
		return FALSE;

	ulReval = SKF_Encrypt(g_hSessionKey, plaintext, ulPlainLen1, NULL, &ulCipherLen1);
	SHOW_ERROR_EX("Encrypt1", ulReval);
	if (SAR_OK != ulReval)
		return FALSE;


	ulReval = SKF_Encrypt(g_hSessionKey, plaintext, ulPlainLen1, ciphertext1, &ulCipherLen1);
	SHOW_ERROR_EX("Encrypt2", ulReval);
	if (SAR_OK != ulReval)
		return FALSE;
*/
    HANDLE hMac =  0;
    ulReval = SKF_MacInit(g_hSessionKey, &param, &hMac);
    SHOW_ERROR_EX("MacInit1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_Mac(hMac, plaintext, ulPlainLen1, ciphertext2, &ulCipherLen2);
    SHOW_ERROR_EX("Mac", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

/*	if (16 != ulCipherLen2 || 0 != memcmp(ciphertext1 + ulCipherLen1 - 32, ciphertext2, 16))
	{
		SHOW_ERROR(SAR_FAIL);
	}
*/
    BYTE ciphertext3[300] = {0};
    ULONG ulCipherLen3 = 300;
    ulReval = SKF_MacInit(g_hSessionKey, &param, &hMac);
    SHOW_ERROR_EX("MacInit2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_MacUpdate(hMac, plaintext, 10);
    SHOW_ERROR_EX("MacUpdate1", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_MacUpdate(hMac, plaintext + 10, ulPlainLen1 - 10);
    SHOW_ERROR_EX("MacUpdate2", ulReval);
    if (SAR_OK != ulReval)
        return FALSE;

    ulReval = SKF_MacFinal(hMac, ciphertext3, &ulCipherLen3);
    SHOW_ERROR_EX("MacFinal", ulReval);

    if (16 != ulCipherLen3 || 0 != memcmp(ciphertext3, ciphertext2, 16))
    {
        SHOW_ERROR(SAR_FAIL);
        return FALSE;
    }

    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_GenEccKey()
{
    SHOW_PROCESS("Test_GenEccKey");
    ULONG ulReval;
    ECCPUBLICKEYBLOB  EccPubBlob;

    ulReval = SKF_GenECCKeyPair(g_hCurContainer,SGD_SM2_1,&EccPubBlob);
    SHOW_ERROR_EX("GenEccKeyPair", ulReval);
    return (SAR_OK == ulReval);
}

BOOL CCryptoTest::Test_ImportEccKeyPair()
{
    SHOW_PROCESS("Test_ImportEccKeyPair");
    ULONG rv;
    ULONG rLen;
    ECCPUBLICKEYBLOB pEccSignKey;
    ECCCIPHERBLOB  *pEccCipherBlob=NULL;

    ENVELOPEDKEYBLOB EnvelopedKeyBlob;
    unsigned char pbWrappedKey[32]={0},pbTmpData[1024]={0},pbEncryptedData[1024]={0},pbData[1024]={0};
    ULONG ulWrappedKeyLen=32,ulTmpDataLen=1024,ulEncryptedDataLen=1024;
    BLOCKCIPHERPARAM EncryptParam;
    int offset=0;

    ECCPRIVATEKEYBLOB pEccPriBlb = { 256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x14,0x24,0x83,0x02,0x14,0x20,0x42,0x88,0x02,0x4A,0x10,0x14,0x80,0x00,0x02,0x1C,0x00,0x09,0x83,0x58,0x21,0xAC,0x80,0x00,0xA0,0x13,0x11,0x00,0xA8,0x59}};
    ECCPUBLICKEYBLOB pEccPubBlob = {256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0xEA,0x8A,0x39,0x30,0x20,0x8E,0xFD,0x91,0x32,0xF7,0x1C,0x51,0x0A,0xAB,0x57, 0x43,0x8B,0x3D,0xBC,0x27,0xD3,0x04,0xE7,0x98,0xEC,0xCA,0xF2,0xA0,0xEA,0x74,0xEB},
                                    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x75,0x00,0xD9,0xCF,0xF3,0x0E,0x63,0x10,0x15,0xC7,0x73,0x72,0x8E,0x8C,0x25,0x09,0x38,0x0A,0x22,0xE1,0xE7,0x42,0xB6,0xAB,0xA0,0x9D,0xCF,0x85,0x7C,0x42,0xCC,0xEA}};


    unsigned char *pPubKey = NULL;
    ULONG ulPubKeyLen =0;

    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }
    pPubKey = (unsigned char *)malloc(ulPubKeyLen);
    if(pPubKey == NULL)
    {
        SHOW_ERROR_EX("malloc memory", rv);
        return FALSE;
    }
    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }

    if(ulPubKeyLen != sizeof(ECCPUBLICKEYBLOB))
    {
        SHOW_ERROR_EX("ExportPublicKey", SAR_INVALIDHANDLEERR);
        return FALSE;
    }
    memcpy(&pEccSignKey,pPubKey,ulPubKeyLen);

    pEccCipherBlob = (ECCCIPHERBLOB *)malloc(sizeof(ECCCIPHERBLOB)+16);
    pEccCipherBlob->CipherLen =16;
    HANDLE hSessionKey;
    {
        unsigned char pbSessionKey[32]={0};
        memcpy(pbSessionKey,"1234567812345678",16);
        memset(pbSessionKey,0x01,16);
        rv = SKF_ExtECCEncrypt(g_hDev,&pEccSignKey,pbSessionKey,16,pEccCipherBlob);
        SHOW_ERROR_EX("EccEncrypt", rv);
        if(rv)
        {
            return FALSE;
        }
        rv = SKF_SetSymmKey(g_hDev,pbSessionKey,SGD_SM1_ECB,&hSessionKey);
        SHOW_ERROR_EX("SetSymmKey", rv);
        if(rv)
        {
            return FALSE;
        }
    }
    memcpy(pbTmpData,(char *)&pEccPriBlb.PrivateKey,pEccPriBlb.BitLen/4);
    ulTmpDataLen = pEccPriBlb.BitLen/4;
    EncryptParam.IVLen = 0;
    EncryptParam.PaddingType = 0;
    memset((char *)&EncryptParam,0x00,sizeof(EncryptParam));
    rv = SKF_EncryptInit(hSessionKey,EncryptParam);
    SHOW_ERROR_EX("EncryptInit", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }
    rv = SKF_EncryptUpdate(hSessionKey,pbTmpData+32,ulTmpDataLen-32,pbEncryptedData+32,&ulEncryptedDataLen);
    SHOW_ERROR_EX("EncryptUpdate", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }
    rv = SKF_EncryptFinal(hSessionKey,pbEncryptedData+32+ulEncryptedDataLen,&rLen);
    SHOW_ERROR_EX("EncryptFinal", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }
    ulEncryptedDataLen += rLen;
    EnvelopedKeyBlob.Version = 1;
    EnvelopedKeyBlob.ulSymmAlgID = SGD_SM1_ECB;
    EnvelopedKeyBlob.ulBits = 256;
    EnvelopedKeyBlob.PubKey = pEccPubBlob;
    //memcpy((char *)&(EnvelopedKeyBlob.ECCCipherBlob),pEccCipherBlob,sizeof(EccCipherBlob));
    memcpy((char *)&(EnvelopedKeyBlob.ECCCipherBlob),pEccCipherBlob,sizeof(ECCCIPHERBLOB)+16);
    memcpy((char *)&(EnvelopedKeyBlob.cbEncryptedPriKey),&pbEncryptedData,ulEncryptedDataLen+32);
    rv = SKF_ImportECCKeyPair (g_hCurContainer,&EnvelopedKeyBlob);

    SHOW_ERROR_EX("ImportEccKeyPair", rv);
    return (SAR_OK == rv);
}

BOOL CCryptoTest::Test_EccExportSessionKey()
{
    SHOW_PROCESS("Test_EccExportSessionKey");
    ULONG rv;
    ECCPUBLICKEYBLOB EccPubKey;
    ECCCIPHERBLOB *pData =NULL;
    HANDLE hSessionKey;

    unsigned char *pPubKey = NULL;
    ULONG ulPubKeyLen =0;

    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("SKF_ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }
    pPubKey = (unsigned char *)malloc(ulPubKeyLen);
    if(pPubKey == NULL)
    {
        SHOW_ERROR_EX("malloc memory", SAR_MEMORYERR);
        return FALSE;
    }
    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("SKF_ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }

    if(ulPubKeyLen != sizeof(ECCPUBLICKEYBLOB))
    {
        SHOW_ERROR_EX("SKF_ExportPublicKey", SAR_INVALIDHANDLEERR);
        return FALSE;
    }
    memcpy(&EccPubKey,pPubKey,ulPubKeyLen);
    pData = (ECCCIPHERBLOB *)malloc(sizeof(ECCCIPHERBLOB)+16);
    pData->CipherLen = 16;
    rv = SKF_ECCExportSessionKey (g_hCurContainer, SGD_SM1_ECB, &EccPubKey, pData, &hSessionKey);
    SHOW_ERROR_EX("ECCExportSessionKey", rv);
    return (SAR_OK == rv);
}

BOOL CCryptoTest::Test_EccSignVerify()
{
    SHOW_PROCESS("Test_EccSignVerify");
    ULONG rv;
    unsigned char *pbInData = NULL,pbHashData[33]={0},pbOutData[256]={0};
    ULONG ulInLen=0,ulOutLen=0,ulHashLen =0,ulIdLen = 7;
    ECCSIGNATUREBLOB  Signature;
    ECCPUBLICKEYBLOB  EccPubKey;
    unsigned char pucId[32] ={0};
    HANDLE hHash;
    unsigned char *pPubKey = NULL;
    ULONG ulPubKeyLen =0;

    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }
    pPubKey = (unsigned char *)malloc(ulPubKeyLen);
    if(pPubKey == NULL)
    {
        SHOW_ERROR_EX("malloc memeory", rv);
        return FALSE;
    }
    rv = SKF_ExportPublicKey(g_hCurContainer,TRUE,pPubKey,&ulPubKeyLen);
    SHOW_ERROR_EX("ExportPublicKey", rv);
    if(rv)
    {
        return FALSE;
    }

    if(ulPubKeyLen != sizeof(ECCPUBLICKEYBLOB))
    {
        SHOW_ERROR_EX("ExportPlubicKey", SAR_INVALIDHANDLEERR);
        return FALSE;
    }
    memcpy(&EccPubKey,pPubKey,ulPubKeyLen);
    memcpy(pucId,"1234567812345678",16);
    ulIdLen = 16;
    rv = SKF_DigestInit(g_hDev,SGD_SM3,&EccPubKey,pucId,ulIdLen,&hHash);
    SHOW_ERROR_EX("DigestInit", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }
    unsigned char pbpalint[32]={0};
    memcpy(pbpalint,"12345678",8);
    ulHashLen = 64;
    rv = SKF_Digest(hHash,pbpalint,8,pbHashData,&ulHashLen);
    SHOW_ERROR_EX("Digest", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }

    rv = SKF_ECCSignData(g_hCurContainer,pbHashData,ulHashLen,&Signature);
    SHOW_ERROR_EX("EccSignData", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }

    rv = SKF_ECCVerify(g_hDev,&EccPubKey,pbHashData,ulHashLen,&Signature);
    SHOW_ERROR_EX("EccVerify", rv);
    return (SAR_OK == rv);
}

BOOL CCryptoTest::Test_ExtEccEncrypt()
{
    SHOW_PROCESS("Test_ExtEccEncrypt");
    ULONG rv;
    unsigned char pbInData[256]={0},*pbOutData = NULL;
    ECCCIPHERBLOB *pCipherText = NULL;
    ULONG ulInLen=0,ulOutLen=0;
    ECCPRIVATEKEYBLOB EccPriKey = { 256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x14,0x24,0x83,0x02,0x14,0x20,0x42,0x88,0x02,0x4A,0x10,0x14,0x80,0x00,0x02,0x1C,0x00,0x09,0x83,0x58,0x21,0xAC,0x80,0x00,0xA0,0x13,0x11,0x00,0xA8,0x59}};
    ECCPUBLICKEYBLOB EccPubKey = {256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0xEA,0x8A,0x39,0x30,0x20,0x8E,0xFD,0x91,0x32,0xF7,0x1C,0x51,0x0A,0xAB,0x57,0x43,0x8B,0x3D,0xBC,0x27,0xD3,0x04,0xE7,0x98,0xEC,0xCA,0xF2,0xA0,0xEA,0x74,0xEB},
                                  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x75,0x00,0xD9,0xCF,0xF3,0x0E,0x63,0x10,0x15,0xC7,0x73,0x72,0x8E,0x8C,0x25,0x09,0x38,0x0A,0x22,0xE1,0xE7,0x42,0xB6,0xAB,0xA0,0x9D,0xCF,0x85,0x7C,0x42,0xCC,0xEA}};

    memcpy(pbInData,"ffeeddccbbaa99887766554433221100ffeeddccbbaa99887766554433221177",32);
    ulInLen = 32;
    pCipherText = (ECCCIPHERBLOB *)malloc(sizeof(ECCCIPHERBLOB)+ulInLen);
    pCipherText->CipherLen = ulInLen;
    rv = SKF_ExtECCEncrypt(g_hDev,&EccPubKey,pbInData,ulInLen,pCipherText);
    SHOW_ERROR_EX("EccEncrypt", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }

    rv = SKF_ExtECCDecrypt(g_hDev,&EccPriKey,pCipherText,NULL,&ulOutLen);
    SHOW_ERROR_EX("EccDecrypt", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }

    pbOutData = (unsigned char *)malloc(ulOutLen);

    rv = SKF_ExtECCDecrypt(g_hDev,&EccPriKey,pCipherText,pbOutData,&ulOutLen);
    SHOW_ERROR_EX("EccDecrypt", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }

    if( (ulInLen != ulOutLen) || (0 != memcmp(pbInData,pbOutData,ulOutLen) ) )
    {
        SHOW_ERROR_EX("Ecc Encrypt Decrypt", SAR_FAIL);
        return FALSE;
    }
    SHOW_ERROR_EX("Ecc Encrypt Decrypt", SAR_OK);
    return TRUE;
}

BOOL CCryptoTest::Test_ExtEccSignVerify()
{
    SHOW_PROCESS("Test_ExtEccSignVerify");
    ULONG rv;
    unsigned char pbInData[2048]={0},pbOutData[256]={0};
    ULONG ulInLen=0,ulOutLen=0;
    ECCSIGNATUREBLOB  Signature;

    ECCPRIVATEKEYBLOB EccPriKey = { 256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x14,0x24,0x83,0x02,0x14,0x20,0x42,0x88,0x02,0x4A,0x10,0x14,0x80,0x00,0x02,0x1C,0x00,0x09,0x83,0x58,0x21,0xAC,0x80,0x00,0xA0,0x13,0x11,0x00,0xA8,0x59}};
    ECCPUBLICKEYBLOB EccPubKey = {256,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x26,0xEA,0x8A,0x39,0x30,0x20,0x8E,0xFD,0x91,0x32,0xF7,0x1C,0x51,0x0A,0xAB,0x57,0x43,0x8B,0x3D,0xBC,0x27,0xD3,0x04,0xE7,0x98,0xEC,0xCA,0xF2,0xA0,0xEA,0x74,0xEB},
                                  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x75,0x00,0xD9,0xCF,0xF3,0x0E,0x63,0x10,0x15,0xC7,0x73,0x72,0x8E,0x8C,0x25,0x09,0x38,0x0A,0x22,0xE1,0xE7,0x42,0xB6,0xAB,0xA0,0x9D,0xCF,0x85,0x7C,0x42,0xCC,0xEA}};

    for(int i= 0;i<2048;i++)
        pbInData[i] = (i+1)%256;
    ulInLen = 32;
    rv = SKF_ExtECCSign(g_hDev,&EccPriKey,pbInData,ulInLen,&Signature);
    SHOW_ERROR_EX("ExtEccSign", rv);
    if(rv != SAR_OK)
    {
        return FALSE;
    }
    rv = SKF_ExtECCVerify(g_hDev,&EccPubKey,pbInData,ulInLen,&Signature);

    SHOW_ERROR_EX("ExtEccVerify", rv);
    return (SAR_OK == rv);
}
